{"ast":null,"code":"import strings from \"../localization\";\nimport ValidatorTypes from \"../constants/ValidatorTypes\";\nimport { isNumeric } from \"../util/DataValidation\";\nexport function hasError(errors, type) {\n  return errors[type] && errors[type].length > 0;\n}\nexport default function getErrorClass(errors, type) {\n  return hasError(errors, type) ? \"error\" : \"\";\n}\nexport function validate(formData, validationList) {\n  let errors = {};\n\n  for (let propertyKey of Object.keys(validationList)) {\n    let fieldErrors = [];\n    validationList[propertyKey].forEach(validationItem => {\n      if (validationItem.type === ValidatorTypes.REQUIRED) {\n        if (!required(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.MIN_LENGTH) {\n        if (!minLength(formData[propertyKey], validationItem.min)) {\n          fieldErrors.push({\n            message: `${strings.validation.MinLengthErrorMessage}${validationItem.min}`\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.MAX_LENGTH) {\n        if (!maxLength(formData[propertyKey], validationItem.max)) {\n          fieldErrors.push({\n            message: `${strings.validation.MaxLengthErrorMessage}${validationItem.max}`\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.EMAIL) {\n        if (!email(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.EmailErrorMessage\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.PASSWORD) {\n        if (!password(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.PasswordErrorMessage\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.NOT_EMPTY_ARRAY) {\n        if (!notEmptyArray(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.SELECTED_OPTION) {\n        if (!formData[propertyKey] || formData[propertyKey] === \"-1\") {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.IS_NUMBER) {\n        if (!isNumeric(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.notNumber\n          });\n        }\n      }\n    });\n    errors[propertyKey] = fieldErrors;\n  }\n\n  return errors;\n}\n\nfunction notEmptyArray(data) {\n  return !(!data || data.length === 0);\n}\n\nfunction required(data) {\n  return !(!data || data === \"\");\n}\n\nfunction minLength(data, minLength) {\n  return data && data.length >= minLength;\n}\n\nfunction maxLength(data, maxLength) {\n  return data && data.length <= maxLength;\n}\n\nfunction email(data) {\n  let regexp = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return regexp.test(data);\n}\n\nfunction password(data) {\n  let regexp = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n  return regexp.test(data);\n}\n\nexport function isFormValid(errors) {\n  for (let key in errors) {\n    let error = errors[key];\n\n    if (error.length !== 0) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/korisnik/Desktop/Borkovac/MyProjects/Matchmaker/Matchmaker/matchmaker/src/functions/Validation.js"],"names":["strings","ValidatorTypes","isNumeric","hasError","errors","type","length","getErrorClass","validate","formData","validationList","propertyKey","Object","keys","fieldErrors","forEach","validationItem","REQUIRED","required","push","message","validation","RequiredErrorMessage","MIN_LENGTH","minLength","min","MinLengthErrorMessage","MAX_LENGTH","maxLength","max","MaxLengthErrorMessage","EMAIL","email","EmailErrorMessage","PASSWORD","password","PasswordErrorMessage","NOT_EMPTY_ARRAY","notEmptyArray","SELECTED_OPTION","IS_NUMBER","notNumber","data","regexp","test","isFormValid","key","error"],"mappings":"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","sourcesContent":["import strings from \"../localization\";\nimport ValidatorTypes from \"../constants/ValidatorTypes\";\nimport { isNumeric } from \"../util/DataValidation\";\n\nexport function hasError(errors, type) {\n  return errors[type] && errors[type].length > 0;\n}\n\nexport default function getErrorClass(errors, type) {\n  return hasError(errors, type) ? \"error\" : \"\";\n}\n\nexport function validate(formData, validationList) {\n  let errors = {};\n\n  for (let propertyKey of Object.keys(validationList)) {\n    let fieldErrors = [];\n\n    validationList[propertyKey].forEach((validationItem) => {\n      if (validationItem.type === ValidatorTypes.REQUIRED) {\n        if (!required(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.MIN_LENGTH) {\n        if (!minLength(formData[propertyKey], validationItem.min)) {\n          fieldErrors.push({\n            message: `${strings.validation.MinLengthErrorMessage}${validationItem.min}`,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.MAX_LENGTH) {\n        if (!maxLength(formData[propertyKey], validationItem.max)) {\n          fieldErrors.push({\n            message: `${strings.validation.MaxLengthErrorMessage}${validationItem.max}`,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.EMAIL) {\n        if (!email(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.EmailErrorMessage,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.PASSWORD) {\n        if (!password(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.PasswordErrorMessage,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.NOT_EMPTY_ARRAY) {\n        if (!notEmptyArray(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.SELECTED_OPTION) {\n        if (!formData[propertyKey] || formData[propertyKey] === \"-1\") {\n          fieldErrors.push({\n            message: strings.validation.RequiredErrorMessage,\n          });\n        }\n      } else if (validationItem.type === ValidatorTypes.IS_NUMBER) {\n        if (!isNumeric(formData[propertyKey])) {\n          fieldErrors.push({\n            message: strings.validation.notNumber,\n          });\n        }\n      }\n    });\n\n    errors[propertyKey] = fieldErrors;\n  }\n\n  return errors;\n}\n\nfunction notEmptyArray(data) {\n  return !(!data || data.length === 0);\n}\n\nfunction required(data) {\n  return !(!data || data === \"\");\n}\n\nfunction minLength(data, minLength) {\n  return data && data.length >= minLength;\n}\n\nfunction maxLength(data, maxLength) {\n  return data && data.length <= maxLength;\n}\n\nfunction email(data) {\n  let regexp = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  return regexp.test(data);\n}\n\nfunction password(data) {\n  let regexp = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{6,}$/;\n  return regexp.test(data);\n}\n\nexport function isFormValid(errors) {\n  for (let key in errors) {\n    let error = errors[key];\n    if (error.length !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}